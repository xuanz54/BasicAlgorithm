# 螺旋矩阵

## 一、题目

定义n阶间断折叠方阵是把n2个整数折叠填写到n阶方阵中，起始数1置于方阵的左上角，然后从起始数开始递增，每一层从第一行开始。先向下再折转向左，层层折叠的排列为间断折叠方阵，请构造并输出n阶间断折叠方阵。请实现函数int[][] FoldingMatrix(int n)，其中n为方阵的阶数，返回的int[][]为构造出的n×n间断折叠方阵。



![image-20240906175308438](https://gitee.com/xuanz54/images_repository/raw/master/imgs/image-20240906175308438.png)



## 二、详细代码

```python
def FoldingMatrix(n):
    """
    构造一个n×n的矩阵，按指定的折叠规则从1开始递增填充。
    :param n: int, 矩阵的阶数
    :return: list, 构造出的n×n矩阵
    """
    # 创建一个n×n的矩阵，初始化为0
    a = [[0 for _ in range(n)] for _ in range(n)]
    k = 1  # 初始化起始数为1
    a[0][0] = k  # 左上角置为1
    k += 1
    # 逐步填充矩阵
    for i in range(1, n):
        x, y = 0, i  # 初始化位置，行x从0开始，列y从i开始
        a[x][y] = k  # 填充起始位置
        k += 1
        x += 1  # 移动到下一行
        # 填充对角线向下部分
        for j in range(i):
            a[x][y] = k
            k += 1
            x += 1
        x -= 1  # 回退到最后填充的行
        y -= 1  # 向左移动一列
        # 填充对角线向左部分
        for j in range(i):
            a[x][y] = k
            k += 1
            y -= 1
    return a

def print_matrix(matrix):
    """
    按指定格式打印矩阵。
    :param matrix: list, 需要打印的二维列表矩阵
    """
    for row in matrix:
        for elem in row:
            print(f"{elem:4d}", end="")
        print()  # 换行

# 示例运行
n = int(input("请输入方阵的阶数："))  # 从用户获取方阵阶数
matrix = FoldingMatrix(n)
print_matrix(matrix)
def FoldingMatrix(n):
    """
    构造一个n×n的矩阵，按指定的折叠规则从1开始递增填充。
    :param n: int, 矩阵的阶数
    :return: list, 构造出的n×n矩阵
    """
    # 创建一个n×n的矩阵，初始化为0
    a = [[0 for _ in range(n)] for _ in range(n)]
    k = 1  # 初始化起始数为1
    a[0][0] = k  # 左上角置为1
    k += 1
    # 逐步填充矩阵
    for i in range(1, n):
        x, y = 0, i  # 初始化位置，行x从0开始，列y从i开始
        a[x][y] = k  # 填充起始位置
        k += 1
        x += 1  # 移动到下一行
        # 填充对角线向下部分
        for j in range(i):
            a[x][y] = k
            k += 1
            x += 1
        x -= 1  # 回退到最后填充的行
        y -= 1  # 向左移动一列
        # 填充对角线向左部分
        for j in range(i):
            a[x][y] = k
            k += 1
            y -= 1
    return a

def print_matrix(matrix):
    """
    按指定格式打印矩阵。
    :param matrix: list, 需要打印的二维列表矩阵
    """
    for row in matrix:
        for elem in row:
            print(f"{elem:4d}", end="")
        print()  # 换行

# 示例运行
n = int(input("请输入方阵的阶数："))  # 从用户获取方阵阶数
matrix = FoldingMatrix(n)
print_matrix(matrix)
```

## 三、具体过程（建议对着代码逐行分析）

### 关键变量：

- `a`: 是一个 `n×n` 的二维列表（矩阵），初始时所有元素都为 0。
- `k`: 是一个计数器，表示当前要填入的数字，初始值为 1，并在每次填充时递增。
- `x`, `y`: 表示当前正在填充的元素的坐标。

我们以 n=4 为例，逐步填充矩阵。

------

### 初始化：

- 创建一个 4x4 的矩阵，初始值全是 0。
- 初始化 `k=1`，并将第一个数 `1` 填入左上角，即 `a[0][0]`。

```
css复制代码步骤1：
k = 1，填充 a[0][0] = 1

1  0  0  0
0  0  0  0
0  0  0  0
0  0  0  0
```

接下来，我们将进入循环，从 `i=1` 开始，逐步填充矩阵的对角线和左侧。

------

### 第一次循环 (i=1)：

**对角线填充**：

- 我们从 `a[0][1]` 开始（即第 1 行第 2 列），将 `k=2` 填入，然后向下移动，填入 `a[1][1] = 3`。

```
css复制代码步骤2：
k = 2，填充 a[0][1] = 2
k = 3，填充 a[1][1] = 3

1  2  0  0
0  3  0  0
0  0  0  0
0  0  0  0
```

**左侧填充**：

- 回到第 1 行，向左填充，填入 `a[1][0] = 4`。

```
css复制代码步骤3：
k = 4，填充 a[1][0] = 4

1  2  0  0
4  3  0  0
0  0  0  0
0  0  0  0
```

------

### 第二次循环 (i=2)：

**对角线填充**：

- 从 `a[0][2]` 开始，将 `k=5` 填入，然后向下依次填入 `a[1][2] = 6` 和 `a[2][2] = 7`。

```
css复制代码步骤4：
k = 5，填充 a[0][2] = 5
k = 6，填充 a[1][2] = 6
k = 7，填充 a[2][2] = 7

1  2  5  0
4  3  6  0
0  0  7  0
0  0  0  0
```

**左侧填充**：

- 回到最后一个填充的位置，向左依次填入 `a[2][1] = 8` 和 `a[2][0] = 9`。

```
css复制代码步骤5：
k = 8，填充 a[2][1] = 8
k = 9，填充 a[2][0] = 9

1  2  5  0
4  3  6  0
9  8  7  0
0  0  0  0
```

------

### 第三次循环 (i=3)：

**对角线填充**：

- 从 `a[0][3]` 开始，依次填入 `a[0][3] = 10`，`a[1][3] = 11`，`a[2][3] = 12`，`a[3][3] = 13`。

```
css复制代码步骤6：
k = 10，填充 a[0][3] = 10
k = 11，填充 a[1][3] = 11
k = 12，填充 a[2][3] = 12
k = 13，填充 a[3][3] = 13

1  2  5 10
4  3  6 11
9  8  7 12
0  0  0 13
```

**左侧填充**：

- 回到最后一个填充的位置，向左依次填入 `a[3][2] = 14`，`a[3][1] = 15`，`a[3][0] = 16`。

```
css复制代码步骤7：
k = 14，填充 a[3][2] = 14
k = 15，填充 a[3][1] = 15
k = 16，填充 a[3][0] = 16

1  2  5 10
4  3  6 11
9  8  7 12
16 15 14 13
```

------

### 完整的 4×4 矩阵：

经过这几个步骤，最终生成的 4×4 矩阵为：

```
复制代码1  2  5 10
4  3  6 11
9  8  7 12
16 15 14 13
```

### 总结：

- **对角线部分**：每次从对角线位置开始向下填充数字。
- **左侧部分**：对角线填充完成后，再从最后一行的右侧开始向左填充。
- `i` 控制每次的对角线长度，`x` 和 `y` 控制当前填充的位置，`k` 负责递增计数。
